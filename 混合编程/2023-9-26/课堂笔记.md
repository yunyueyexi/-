# C++ 编程基础



## 面向对象编程(OOP)



### 多态

多种形态，具体来说就是同一种调用形式具有多种不同的执行效果。

在 C++ 中，通过虚函数（或虚方法）和父类指针/引用实现。

虚函数(Virtual Function)：就是用 virtual 关键字修饰的方法。

**在父类指针/引用指向子类对象（向上转型）的前提下，此时如果子类重写了父类中某个虚函数，通过父类指针/引用去调用该虚函数时，执行的将是子类中的方法，否则执行的是父类中的方法。**

> 一旦定义了虚函数，每个对象（包括子类对象）都会存放虚函数表(Virtual Table)的指针，从而实现上面的功能。



方法重写(Override)：子类中重新定义了父类（直接父类或间接父类）中某个虚函数。



> 方法重载(Overload)：在一个类中，多个方法同名但形参类型或个数不同，或者 const 和 非 const。
>
> 同名覆盖：子类中定义了和父类（直接父类或间接父类）中同名的属性或方法。



**纯虚函数(Pure Virtual Function)**：只有声明却没有实现（即没有函数体）的方法，其声明的语法形式也很独特。

```C++
virtual void speak(int i) = 0;
```



**抽象类(Abstract Class)**：含有纯虚函数的类。抽象类不能被实例化，即不能用于创建对象。

抽象类的子类如果不重写从父类（包括间接父类）继承的所有纯虚函数，那么它也是一个抽象类。

抽象类不能用于定义对象，但可以用于定义指针/引用，它主要是用来当父类使用，并且通过父类指针/引用指向子类对象，然后调用虚函数和纯虚函数。



虚析构函数的作用：通过父类指针/引用指向堆区子类对象，在释放时默认只会调用父类的析构函数，不会调用子类的析构函数，如果将父类中的析构函数定义为虚函数，就能避免这个问题。

父类析构函数如果为虚函数，子类的析构函数将自动成为虚函数，即使不写 virtual 关键字，当然写上 virtual 关键字可读性更好。



### 内联函数(Inline Function)

```c++
#define  max(a, b)  (((a) > (b)) ? (a) : (b))  // 宏定义

// 预处理阶段：max(i, 3) -->  (((i) > (3)) ? (i) : (3))

int max(int a, int b)  // 函数定义
{
    return (((a) > (b)) ? (a) : (b));
}
```



使用 inline 关键字修饰的函数，和普通函数不同，它会被编译器展开，效率更高，但不建议实现代码量很多的函数。



### C 和 C++ 混合编程问题

